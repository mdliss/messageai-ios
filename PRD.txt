# Advanced AI Features for MessageAI - Product Requirements Document

## Executive Summary

**all rubric requirements are complete.** messageai already has a full suite of ai features including thread summarization, action items extraction, rag based semantic search, priority detection, and decision tracking. this prd defines three **advanced, beyond rubric ai features** that will transform messageai from a great messaging app into an indispensable management tool for busy remote managers.

these three premium features are:

1. **smart response suggestions** - ai powered suggested replies that save managers hours per week by providing contextually perfect response options they can use or edit with one tap
2. **proactive blocker detection** - automatic scanning of all team conversations to identify when team members are stuck, blocked, or need help before they have to ask multiple times
3. **team sentiment analysis** - continuous mood and morale tracking across all conversations to help managers spot burnout, stress, or team dynamics issues days before they would normally notice

these features position messageai as **the ai management assistant every remote team lead needs**, not just another messaging app.

## Background and Context

### what messageai already has (rubric complete)

**core messaging (35/35 points):**
- ‚úÖ real time message delivery < 200ms
- ‚úÖ offline support with queue and sync < 1s
- ‚úÖ group chat with 3+ participants
- ‚úÖ read receipts and typing indicators
- ‚úÖ image sharing with compression
- ‚úÖ presence system (online/offline)

**mobile quality (20/20 points):**
- ‚úÖ app lifecycle handling
- ‚úÖ performance targets met (60 fps, < 2s launch)
- ‚úÖ error handling and loading states
- ‚úÖ swiftui best practices

**ai features (30/30 points):**
- ‚úÖ thread summarization (gpt 4o, 3 bullet summaries, < 3s)
- ‚úÖ action items extraction (structured output, full crud, 80%+ accuracy)
- ‚úÖ smart search rag pipeline (embeddings, vector similarity, llm answers)
- ‚úÖ priority detection (urgent + important, visual indicators, filter view)
- ‚úÖ decision tracking (auto detect, timeline, poll consensus)

**technical implementation (10/10 points):**
- ‚úÖ clean mvvm architecture
- ‚úÖ api keys secured (cloud functions only)
- ‚úÖ full rag pipeline implemented
- ‚úÖ firebase authentication
- ‚úÖ proper data persistence

**total score: 95/100+ (excellent tier, a grade)**

### why these three new features matter

**the problem:** managers are drowning in messages. they spend 3 4 hours per day reading and responding to team communications. they miss important signals about team health, blockers, and morale until it's too late.

**the opportunity:** messageai already has the infrastructure (cloud functions, ai integration, real time data) to build features that competitors don't have. these three features create clear differentiation and tangible value (time saved, problems prevented, teams supported better).

**the target user:** busy remote managers leading 5 20 person teams across multiple time zones. they value their time highly. they care about their team's well being. they're overwhelmed by communication volume.

### existing architecture (foundation we're building on)

**technology stack:**
- ios app: swift, swiftui, mvvm architecture
- backend: firebase cloud functions (node.js/typescript)
- ai models: openai gpt 4o (analysis), text embedding 3 small (rag)
- database: firestore with subcollections for messages
- local caching: core data for offline support
- api keys: secured in cloud functions only (functions.config().openai.key)

**proven ai function pattern:**
```typescript
export const someAIFunction = functions
  .runWith({ timeoutSeconds: 60, memory: '512MB' })
  .https.onCall(async (data, context) => {
    // 1. auth check
    if (!context.auth) throw error;
    
    // 2. fetch conversation context from firestore
    const messages = await getMessages(conversationId, limit);
    
    // 3. format as transcript
    const transcript = formatAsTranscript(messages);
    
    // 4. call openai with structured prompt
    const response = await openai.chat.completions.create({
      model: 'gpt-4o',
      messages: [
        { role: 'system', content: systemPrompt },
        { role: 'user', content: transcript }
      ]
    });
    
    // 5. parse json response
    const result = parseAIResponse(response);
    
    // 6. save to firestore
    await saveResults(conversationId, result);
    
    // 7. return to client
    return { success: true, data: result };
  });
```

**existing data structure:**
```
firestore:
  /users/{userId}
    - id, email, displayName, photoURL, isOnline, lastSeen, fcmToken
    - preferences { aiEnabled, notificationSettings }
    - avatarType, avatarId (for built in avatars)
  
  /conversations/{conversationId}
    - id, type (direct|group), participantIds[], participantDetails{}
    - lastMessage { text, senderId, timestamp }
    - unreadCount { userId: count }
    - groupName, groupPhotoURL (for groups)
    
    /messages/{messageId}
      - id, conversationId, senderId, senderName, senderPhotoURL
      - type (text|image), text, imageURL
      - createdAt, status (sending|sent|delivered|read)
      - deliveredTo[], readBy[]
      - priority (bool) - for priority detection
      - embedding[] (1536 floats) - for rag search
      
    /insights/{insightId}
      - type (summary|actionItems|decision)
      - content, triggeredBy, createdAt
      
    /polls/{pollId}
      - question, options[], votes{}, status, createdAt
```

## Feature 1: Smart Response Suggestions

### the value proposition

**save managers 30 45 minutes per day** by providing ai generated response options for common situations. instead of typing "yes, let's move the deadline to friday. please update the team and adjust the timeline accordingly" from scratch, managers tap one button.

**maintain communication quality** even when rushed. suggestions match the manager's tone and style, consider full context, and provide professional, thoughtful responses.

**reduce decision fatigue** by offering 3 4 clear options (approve, decline, conditional, delegate) so managers can quickly choose rather than agonize over wording.

### when to show suggestions (trigger logic)

**show suggestions when:**
- message ends with "?" (question)
- message contains request keywords:
  - "can we", "should we", "could you", "would you"
  - "need approval", "need your input", "waiting for"
  - "what do you think", "thoughts on"
- message mentions manager by name or role
- message is flagged as priority
- message explicitly requests decision

**don't show suggestions when:**
- message is purely informational ("fyi the meeting moved to 3pm")
- message is simple acknowledgment ("thanks!", "got it", "ok")
- conversation is casual chat (jokes, water cooler talk)
- message is part of rapid back and forth (< 30 seconds between messages)
- sender is having emotional conversation (ai should not interfere)

### user experience flow

**step 1: manager receives message**
- team member asks: "can we push the deadline for the marketing campaign to next friday? we're behind on the design work."
- message appears in chat normally
- small "ai suggestions available" indicator appears

**step 2: ai analyzes context**
- fetches last 15 20 messages for conversation context
- fetches manager's recent responses from other conversations (for style matching)
- identifies what's being asked (deadline extension request)
- considers who's asking (team member's role, past interactions)
- considers project context from conversation history

**step 3: ai generates suggestions (background, < 3 seconds)**
- creates 3 4 response options covering different scenarios:
  - **option 1 (approve):** "yes, let's move it to friday the 15th. please update the team on slack and adjust the project timeline in asana accordingly."
  - **option 2 (conditional):** "what's causing the delay on design? if it's just polish we can extend. if there are blockers we need to discuss in tomorrow's standup."
  - **option 3 (decline):** "we need to keep the original deadline because [stakeholder] is expecting delivery tuesday. what support or resources do you need to make it happen?"
  - **option 4 (delegate):** "let me check with stakeholders on monday. in the meantime can you send me a revised timeline showing the new milestones and what you'll deliver by the original deadline?"

**step 4: manager reviews suggestions**
- suggestions appear in card below message
- each suggestion is a tappable button
- different colors indicate type:
  - green: approve/positive
  - orange: conditional/clarifying
  - red: decline/push back
  - blue: delegate/defer
- manager can:
  - tap suggestion to insert into message input (does not auto send)
  - tap "edit" to modify before inserting
  - tap "more options" to generate 2 3 additional suggestions
  - tap "x" to dismiss all suggestions
  - ignore suggestions and type own response

**step 5: manager uses suggestion**
- taps suggestion button
- text inserts into message input field (cursor at end)
- manager can edit if needed (add personal touch, adjust details)
- manager sends message normally
- suggestion feedback saved (which type was used, was it edited)

**step 6: ai learns over time**
- tracks which suggestions get used vs ignored
- tracks how often suggestions get edited before sending
- learns manager's preferred phrasing patterns
- adapts future suggestions to match manager's evolving style
- reduces unhelpful suggestion types

### suggestion quality requirements

**each suggestion must:**
- be contextually appropriate to the specific situation
- match manager's communication style (formal/casual, brief/detailed)
- be actionable and complete (not vague or generic)
- consider relevant conversation history
- be professional and clear
- provide different approach options (not 4 variations of "yes")

**avoid:**
- overly generic responses ("sounds good!", "let me think about it")
- responses that miss context ("yes to what?")
- responses in wrong tone (overly casual for formal manager)
- responses that contradict previous manager statements
- responses that make commitments manager can't keep

### technical implementation

**new database schema additions:**
```
/conversations/{conversationId}/messages/{messageId}
  - responseSuggestions {
      generatedAt: timestamp
      expiresAt: timestamp (generatedAt + 5 minutes)
      options: [
        {
          id: string
          text: string
          type: 'approve'|'decline'|'conditional'|'delegate'
          reasoning: string (why this fits)
          confidence: number (0.0 to 1.0)
        }
      ]
    }
  
  - suggestionFeedback {
      wasShown: boolean
      wasUsed: boolean
      selectedOptionId: string | null
      wasEdited: boolean
      userRating: 'helpful'|'not_helpful'|null
      createdAt: timestamp
    }
```

**new cloud function: generateResponseSuggestions**

**location:** `functions/src/ai/responseSuggestions.ts`

**configuration:**
- timeout: 10 seconds
- memory: 512mb
- triggers: https callable (manual invocation from app)

**input parameters:**
```typescript
{
  conversationId: string;
  messageId: string;
  currentUserId: string;
}
```

**process:**
1. verify authentication
2. fetch target message requiring response
3. fetch conversation context (last 15 20 messages)
4. fetch manager's recent responses from other conversations (for style analysis)
5. build ai prompt with context
6. call openai gpt 4o
7. parse json response into suggestions array
8. cache suggestions in message document (expires in 5 minutes)
9. return suggestions to client

**ai prompt structure:**
```
system prompt:
you are helping a busy manager respond to team messages efficiently. your job is to generate 3-4 high quality response options that:
1. match the manager's communication style (examples provided)
2. are contextually appropriate to the situation
3. cover different response types (approve, decline, conditional, delegate)
4. are professional, clear, and actionable
5. consider the full conversation context

return json array only, no markdown, no explanation.

user prompt:
conversation context (last 20 messages):
${formattedTranscript}

message requiring response:
"${messageText}" - from ${senderName} at ${timestamp}

manager's typical style (recent responses from other conversations):
${managerStyleExamples}

generate 3-4 response options. for each option:
- text: the complete response the manager can send
- type: 'approve' | 'decline' | 'conditional' | 'delegate'
- reasoning: one sentence explaining why this fits

return json:
[
  {
    "text": "suggested response text here",
    "type": "approve",
    "reasoning": "approves request and provides clear next steps"
  }
]
```

**caching strategy:**
- cache generated suggestions in message document
- set expiration: 5 minutes from generation
- if conversation continues (new messages after target message), invalidate cache
- check cache before calling ai (avoid redundant expensive calls)

**swift integration:**

**new model:** `ResponseSuggestion.swift`
```swift
struct ResponseSuggestion: Identifiable, Codable, Equatable {
    let id: String
    let text: String
    let type: SuggestionType
    let reasoning: String
    let confidence: Double
}

enum SuggestionType: String, Codable {
    case approve
    case decline
    case conditional
    case delegate
    
    var color: Color {
        switch self {
        case .approve: return .green
        case .decline: return .red
        case .conditional: return .orange
        case .delegate: return .blue
        }
    }
    
    var icon: String {
        switch self {
        case .approve: return "checkmark.circle.fill"
        case .decline: return "xmark.circle.fill"
        case .conditional: return "questionmark.circle.fill"
        case .delegate: return "arrow.right.circle.fill"
        }
    }
}
```

**new viewmodel:** `ResponseSuggestionsViewModel.swift`
```swift
@MainActor
class ResponseSuggestionsViewModel: ObservableObject {
    @Published var suggestions: [ResponseSuggestion] = []
    @Published var isLoading = false
    @Published var errorMessage: String?
    
    private let functions = FirebaseConfig.shared.functions
    
    func generateSuggestions(for message: Message, in conversationId: String, currentUserId: String) async {
        isLoading = true
        errorMessage = nil
        
        do {
            let result = try await functions.httpsCallable("generateResponseSuggestions").call([
                "conversationId": conversationId,
                "messageId": message.id,
                "currentUserId": currentUserId
            ])
            
            guard let data = result.data as? [String: Any],
                  let optionsData = data["options"] as? [[String: Any]] else {
                throw NSError(domain: "ResponseSuggestions", code: -1)
            }
            
            self.suggestions = try optionsData.map { optionDict in
                let jsonData = try JSONSerialization.data(withJSONObject: optionDict)
                return try JSONDecoder().decode(ResponseSuggestion.self, from: jsonData)
            }
            
            self.isLoading = false
        } catch {
            print("‚ùå failed to generate suggestions: \(error)")
            self.errorMessage = "couldn't generate suggestions"
            self.isLoading = false
        }
    }
    
    func selectSuggestion(_ suggestion: ResponseSuggestion, messageId: String, conversationId: String) {
        // track selection in firestore for learning
        Task {
            await recordSuggestionUsage(messageId: messageId, conversationId: conversationId, suggestionId: suggestion.id)
        }
    }
    
    func dismissSuggestions() {
        suggestions = []
    }
    
    private func recordSuggestionUsage(messageId: String, conversationId: String, suggestionId: String) async {
        // save feedback to firestore
        // this data helps ai learn and improve future suggestions
    }
}
```

**new view:** `ResponseSuggestionsCard.swift`
```swift
struct ResponseSuggestionsCard: View {
    @ObservedObject var viewModel: ResponseSuggestionsViewModel
    let onSelectSuggestion: (String) -> Void
    
    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            // header
            HStack {
                Image(systemName: "sparkles")
                    .foregroundColor(.blue)
                Text("ai suggestions")
                    .font(.subheadline)
                    .fontWeight(.semibold)
                Spacer()
                Button(action: viewModel.dismissSuggestions) {
                    Image(systemName: "xmark.circle.fill")
                        .foregroundColor(.gray)
                }
            }
            
            if viewModel.isLoading {
                HStack {
                    ProgressView()
                    Text("generating suggestions...")
                        .font(.caption)
                        .foregroundColor(.gray)
                }
            } else {
                ForEach(viewModel.suggestions) { suggestion in
                    SuggestionButton(
                        suggestion: suggestion,
                        action: { onSelectSuggestion(suggestion.text) }
                    )
                }
            }
        }
        .padding()
        .background(Color(.systemGray6))
        .cornerRadius(12)
        .padding(.horizontal)
    }
}

struct SuggestionButton: View {
    let suggestion: ResponseSuggestion
    let action: () -> Void
    
    var body: some View {
        Button(action: action) {
            HStack {
                Image(systemName: suggestion.type.icon)
                    .foregroundColor(suggestion.type.color)
                
                VStack(alignment: .leading, spacing: 4) {
                    Text(suggestion.text)
                        .font(.body)
                        .foregroundColor(.primary)
                        .multilineTextAlignment(.leading)
                    
                    Text(suggestion.reasoning)
                        .font(.caption)
                        .foregroundColor(.gray)
                }
                
                Spacer()
            }
            .padding()
            .background(Color(.systemBackground))
            .cornerRadius(8)
        }
        .buttonStyle(.plain)
    }
}
```

**integration into chatview:**
- add ResponseSuggestionsViewModel
- detect when message needs response (check trigger conditions)
- call generateSuggestions automatically or show "get suggestions" button
- display ResponseSuggestionsCard below message
- when suggestion selected, insert into message input field
- user can edit before sending
- track usage for learning

**performance targets:**
- generate suggestions in < 3 seconds (95th percentile)
- cache hits should be instant
- timeout after 5 seconds if ai doesn't respond
- gracefully handle failures (don't block user from typing)
- show loading state while generating

## Feature 2: Proactive Blocker Detection

### the value proposition

**prevent productivity loss** by catching team member blockers early. when someone is stuck waiting for approval, access, or help, managers find out immediately instead of in the next standup 24 hours later.

**reduce team frustration** by ensuring blockers don't go unanswered. team members feel supported when managers proactively reach out, rather than them having to ask for help multiple times.

**improve project velocity** by identifying and removing blockers faster. average blocker resolution time drops from days to hours.

### what constitutes a blocker

a team member is blocked when they explicitly or implicitly indicate they:
- cannot proceed with their work until something happens
- are waiting for someone to respond or approve
- don't have access to resources they need
- are stuck on a technical problem they can't solve
- need help but aren't getting responses

### blocker detection patterns

**explicit blocker statements:**
- "i'm blocked on [thing]"
- "i'm stuck on [thing]"
- "can't proceed until [thing]"
- "waiting for [thing/person]"
- "need help with [thing]"
- "unable to complete because [reason]"

**approval and decision blockers:**
- "waiting for approval on [thing]"
- "can someone review [thing]"
- "need sign off from [person]"
- "who can approve [thing]"
- "is this approved to move forward"

**resource and access blockers:**
- "don't have access to [system/tool]"
- "need credentials for [thing]"
- "can't find [resource]"
- "missing information about [thing]"
- "need [permission/license/account]"

**technical blockers:**
- "this error keeps happening"
- "can't figure out why [thing] isn't working"
- "the system won't let me [action]"
- "getting error: [error message]"
- "tried everything, still broken"

**people blockers:**
- "waiting for [person] to respond"
- "[person] hasn't gotten back to me"
- "need [person] to [action]"
- "can someone connect me with [person/team]"
- "who should i talk to about [thing]"

**time based patterns (implicit blockers):**
- someone mentions being stuck and no one responds for 2+ hours (during work hours)
- same issue mentioned multiple times over multiple days
- repeated requests for help going unanswered
- question asked in multiple conversations (escalating frustration)

### blocker severity classification

**critical (red) - immediate manager attention required:**
- blocks production deployment or customer facing issue
- multiple people blocked by same root cause
- blocker has been unresolved for 24+ hours
- affects hard deadlines or external commitments
- team member explicitly says "urgent" or "blocking release"

**high (orange) - manager should address today:**
- blocks significant feature development or sprint goal
- person has been waiting 6+ hours during work day
- no one has responded to help request
- affects team milestone or demo
- team member showing frustration in messages

**medium (yellow) - manager should address this week:**
- blocks individual productivity but not critical path
- waiting 2 4 hours for response
- someone is helping but progress is slow
- can be worked around temporarily
- mentioned casually, not urgent

**low (blue) - manager should be aware:**
- minor inconvenience, doesn't stop all progress
- just mentioned, no significant time elapsed
- already being addressed by team
- more of a question than a blocker
- team member has other work they can do meanwhile

### user experience flow

**step 1: background monitoring (invisible to user)**
- ai continuously scans all conversations manager is part of
- uses firestore triggers on new message creation
- runs blocker detection on messages containing keywords
- background processing doesn't slow down message delivery

**step 2: blocker detected**
- team member (sarah) sends: "i'm blocked on the api integration. waiting for the auth token from devops for 6 hours now"
- ai analyzes message and surrounding context
- determines: is blocker, type: people + resource, severity: high

**step 3: ai analyzes severity**
- how urgent? sarah can't make progress, has been waiting 6 hours
- who can help? devops team mentioned in message
- impact? affects sprint goal (api integration is critical path)
- classification: high severity (orange)

**step 4: manager receives alert (for high/critical only)**
- push notification: "sarah is blocked - waiting for auth token from devops (6 hours)"
- badge appears on blocker dashboard icon showing "1"
- notification is actionable (taps to view blocker details)

**step 5: manager views blocker dashboard**
- opens blocker dashboard from main navigation
- sees all active blockers sorted by severity then time
- sarah's blocker card shows:
  - name: sarah chen
  - avatar and online status
  - blocker description: "waiting for auth token from devops"
  - detected: 6 hours ago
  - severity: high (orange indicator)
  - suggested actions:
    - "reach out to devops team"
    - "escalate to platform lead"
    - "check if sarah can use staging token temporarily"
  - buttons: view conversation, mark resolved, snooze

**step 6: manager takes action**
- taps "view conversation" to see full context
- messages devops team: "hey can someone help sarah with the auth token for api integration? she's been waiting 6 hours and it's blocking her sprint work"
- or taps sarah's card to message her directly: "i'll ping devops for you, should have the token in next hour"
- or marks resolved if already handled elsewhere

**step 7: manager marks resolved**
- taps "mark resolved" button
- optional: adds resolution note ("pinged devops, token sent")
- blocker removed from active list
- resolution timestamp and manager recorded
- history kept for retrospectives

**alternative flows:**
- **snooze**: manager can snooze for 1 hour, 4 hours, or 1 day if not urgent right now
- **false positive**: manager can mark as "not a blocker" to improve ai accuracy
- **daily summary**: manager gets "3 blockers detected today" notification at end of day (batch mode)

### blocker dashboard design

**main view:**
- navigation title: "team blockers"
- tab badge shows count of critical + high severity blockers
- filter options: all, critical only, high+, by team member
- sort options: severity (default), time, team member name

**blocker card:**
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ üî¥ CRITICAL  |  6 hours ago             ‚îÇ
‚îÇ                                          ‚îÇ
‚îÇ üë§ Sarah Chen (online)                  ‚îÇ
‚îÇ                                          ‚îÇ
‚îÇ Blocked on: Waiting for auth token      ‚îÇ
‚îÇ from DevOps                              ‚îÇ
‚îÇ                                          ‚îÇ
‚îÇ Type: People + Resource                 ‚îÇ
‚îÇ                                          ‚îÇ
‚îÇ Suggested actions:                       ‚îÇ
‚îÇ ‚Ä¢ Reach out to DevOps team              ‚îÇ
‚îÇ ‚Ä¢ Escalate to Platform Lead             ‚îÇ
‚îÇ                                          ‚îÇ
‚îÇ [View Conversation] [Mark Resolved]     ‚îÇ
‚îÇ              [Snooze ‚ñº]                  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**empty state:**
"no active blockers detected üéâ
your team is flowing smoothly!"

### technical implementation

**new database schema:**

```
/conversations/{conversationId}/blockers/{blockerId}
  id: string (auto generated)
  detectedAt: timestamp
  messageId: string (reference to message that triggered detection)
  blockedUserId: string
  blockedUserName: string
  blockerDescription: string (ai generated summary)
  blockerType: 'explicit'|'approval'|'resource'|'technical'|'people'|'time_based'
  severity: 'critical'|'high'|'medium'|'low'
  status: 'active'|'resolved'|'snoozed'|'false_positive'
  suggestedActions: string[] (ai generated)
  conversationId: string
  
  // resolution tracking
  resolvedAt: timestamp | null
  resolvedBy: string | null (manager user id)
  resolutionNotes: string | null
  
  // snooze tracking
  snoozedUntil: timestamp | null
  
  // for learning
  confidence: number (0.0 to 1.0)
  managerMarkedFalsePositive: boolean

/users/{userId}/blockerAlerts/{alertId}
  id: string
  blockerId: string (reference to blocker document)
  conversationId: string
  severity: string
  blockerDescription: string (for notification text)
  createdAt: timestamp
  read: boolean
  dismissed: boolean
```

**firestore indexes needed:**
```json
{
  "collectionGroup": "blockers",
  "queryScope": "COLLECTION",
  "fields": [
    {"fieldPath": "status", "order": "ASCENDING"},
    {"fieldPath": "severity", "order": "ASCENDING"},
    {"fieldPath": "detectedAt", "order": "DESCENDING"}
  ]
}
```

**new cloud function: detectBlocker**

**location:** `functions/src/ai/blockerDetection.ts`

**configuration:**
- timeout: 15 seconds
- memory: 512mb
- triggers: firestore onCreate trigger + https callable (for manual checks)

**firestore trigger:**
```typescript
export const onMessageCreatedCheckBlocker = functions.firestore
  .document('conversations/{conversationId}/messages/{messageId}')
  .onCreate(async (snap, context) => {
    const message = snap.data();
    const conversationId = context.params.conversationId;
    const messageId = context.params.messageId;
    
    // only check text messages
    if (message.type !== 'text') return;
    
    // check for blocker keywords (fast filter before expensive ai call)
    const blockerKeywords = [
      'blocked', 'stuck', 'waiting for', "can't proceed",
      'need help', 'unable to', "don't have access",
      'need approval', 'who can', 'need credentials'
    ];
    
    const messageText = message.text.toLowerCase();
    const mightBeBlocker = blockerKeywords.some(keyword => 
      messageText.includes(keyword)
    );
    
    if (!mightBeBlocker) {
      console.log(`‚è≠Ô∏è message ${messageId} doesn't contain blocker keywords, skipping ai analysis`);
      return;
    }
    
    // call ai to analyze if this is actually a blocker
    console.log(`üîç potential blocker detected in message ${messageId}, running ai analysis...`);
    
    try {
      await detectBlocker({ conversationId, messageId });
    } catch (error) {
      console.error(`‚ùå blocker detection failed for ${messageId}:`, error);
      // don't throw - detection failure shouldn't break message delivery
    }
  });
```

**main detectBlocker function:**
```typescript
export const detectBlocker = functions
  .runWith({ timeoutSeconds: 15, memory: '512MB' })
  .https.onCall(async (data, context) => {
    const { conversationId, messageId } = data;
    
    console.log(`üîç analyzing message ${messageId} for blockers...`);
    
    // fetch message and context
    const messageDoc = await admin.firestore()
      .collection('conversations').doc(conversationId)
      .collection('messages').doc(messageId)
      .get();
    
    if (!messageDoc.exists) {
      throw new functions.https.HttpsError('not-found', 'message not found');
    }
    
    const message = messageDoc.data();
    
    // fetch surrounding messages for context (last 20)
    const contextMessages = await admin.firestore()
      .collection('conversations').doc(conversationId)
      .collection('messages')
      .orderBy('createdAt', 'desc')
      .limit(20)
      .get();
    
    const transcript = contextMessages.docs
      .reverse()
      .map(doc => {
        const msg = doc.data();
        const timestamp = msg.createdAt.toDate();
        const timeStr = timestamp.toLocaleTimeString('en-US', { 
          hour: '2-digit', 
          minute: '2-digit' 
        });
        return `[${timeStr}] ${msg.senderName}: ${msg.text}`;
      })
      .join('\n');
    
    // call openai to analyze
    const apiKey = functions.config().openai?.key;
    if (!apiKey) {
      throw new functions.https.HttpsError('failed-precondition', 'openai api key not configured');
    }
    
    const openai = new OpenAI({ apiKey });
    
    const prompt = `analyze this message to determine if the sender is blocked or stuck on their work.

conversation context (last 20 messages):
${transcript}

message to analyze:
"${message.text}" - sent by ${message.senderName}

determine:
1. is this person blocked or stuck? (yes/no)
2. if yes, what specifically are they blocked on? (brief description, 5-10 words)
3. blocker type: explicit, approval, resource, technical, people, time_based
4. severity: critical, high, medium, low (based on urgency, impact, time waited)
5. suggested actions for manager (2-3 specific actions, each 5-10 words)
6. confidence in this analysis (0.0 to 1.0)

severity guidelines:
- critical: blocks production/release, multiple people affected, 24+ hours, hard deadline
- high: blocks sprint work, 6+ hours waiting, no response to help request
- medium: blocks individual work, 2-4 hours waiting, workarounds possible
- low: minor inconvenience, just mentioned, already being helped

if not blocked, return: {"isBlocked": false}

if blocked, return json (no markdown, no code fences):
{
  "isBlocked": true,
  "description": "waiting for auth token from devops",
  "type": "people",
  "severity": "high",
  "suggestedActions": [
    "reach out to devops team",
    "escalate to platform lead"
  ],
  "confidence": 0.90
}`;

    console.log(`ü§ñ calling gpt-4o for blocker analysis...`);
    
    const response = await openai.chat.completions.create({
      model: 'gpt-4o',
      temperature: 0.3,
      max_tokens: 500,
      messages: [
        {
          role: 'system',
          content: 'you are an expert at identifying when team members are blocked or stuck. analyze messages to detect blockers accurately. return only valid json.'
        },
        {
          role: 'user',
          content: prompt
        }
      ]
    });
    
    const responseText = response.choices[0]?.message?.content || '{}';
    console.log(`üìä ai response: ${responseText}`);
    
    // parse response
    let result;
    try {
      // handle potential markdown code fences
      let jsonText = responseText.trim();
      if (jsonText.startsWith('```')) {
        jsonText = jsonText.replace(/```json?\n?/g, '').replace(/```\n?/g, '');
      }
      result = JSON.parse(jsonText);
    } catch (error) {
      console.error(`‚ùå failed to parse ai response as json:`, error);
      return { success: false, error: 'invalid ai response' };
    }
    
    // if not a blocker, we're done
    if (!result.isBlocked) {
      console.log(`‚úÖ not a blocker, analysis complete`);
      return { success: true, blocker: null };
    }
    
    // only save high confidence blockers
    if (result.confidence < 0.7) {
      console.log(`‚ö†Ô∏è blocker detected but confidence too low (${result.confidence}), not saving`);
      return { success: true, blocker: null, reason: 'low confidence' };
    }
    
    // save blocker to firestore
    console.log(`üíæ saving blocker (severity: ${result.severity}, confidence: ${result.confidence})...`);
    
    const blockerRef = admin.firestore()
      .collection('conversations').doc(conversationId)
      .collection('blockers').doc();
    
    const blocker = {
      id: blockerRef.id,
      detectedAt: admin.firestore.FieldValue.serverTimestamp(),
      messageId: messageId,
      blockedUserId: message.senderId,
      blockedUserName: message.senderName,
      blockerDescription: result.description,
      blockerType: result.type,
      severity: result.severity,
      status: 'active',
      suggestedActions: result.suggestedActions || [],
      conversationId: conversationId,
      confidence: result.confidence,
      managerMarkedFalsePositive: false,
      resolvedAt: null,
      resolvedBy: null,
      resolutionNotes: null,
      snoozedUntil: null
    };
    
    await blockerRef.set(blocker);
    console.log(`‚úÖ blocker saved: ${blockerRef.id}`);
    
    // send notifications to managers (for critical/high only)
    if (result.severity === 'critical' || result.severity === 'high') {
      console.log(`üì≤ blocker is ${result.severity}, sending notifications to managers...`);
      
      // get conversation to find managers (participants)
      const convoDoc = await admin.firestore()
        .collection('conversations').doc(conversationId)
        .get();
      
      if (convoDoc.exists) {
        const conversation = convoDoc.data();
        const participantIds = conversation.participantIds || [];
        
        // create blocker alerts for each participant (except the blocked person)
        for (const userId of participantIds) {
          if (userId === message.senderId) continue; // don't alert the blocked person
          
          const alertRef = admin.firestore()
            .collection('users').doc(userId)
            .collection('blockerAlerts').doc();
          
          await alertRef.set({
            id: alertRef.id,
            blockerId: blockerRef.id,
            conversationId: conversationId,
            severity: result.severity,
            blockerDescription: result.description,
            createdAt: admin.firestore.FieldValue.serverTimestamp(),
            read: false,
            dismissed: false
          });
          
          console.log(`‚úÖ alert created for user ${userId}`);
        }
      }
    }
    
    return { 
      success: true, 
      blocker: {
        id: blockerRef.id,
        ...blocker
      }
    };
  });
```

**swift integration:**

**new models:** `Blocker.swift`
```swift
struct Blocker: Identifiable, Codable {
    let id: String
    let detectedAt: Date
    let messageId: String
    let blockedUserId: String
    let blockedUserName: String
    let blockerDescription: String
    let blockerType: BlockerType
    let severity: BlockerSeverity
    var status: BlockerStatus
    let suggestedActions: [String]
    let conversationId: String
    
    var resolvedAt: Date?
    var resolvedBy: String?
    var resolutionNotes: String?
    var snoozedUntil: Date?
    
    let confidence: Double
    var managerMarkedFalsePositive: Bool
}

enum BlockerType: String, Codable {
    case explicit
    case approval
    case resource
    case technical
    case people
    case timeBased = "time_based"
}

enum BlockerSeverity: String, Codable {
    case critical
    case high
    case medium
    case low
    
    var color: Color {
        switch self {
        case .critical: return .red
        case .high: return .orange
        case .medium: return .yellow
        case .low: return .blue
        }
    }
    
    var icon: String {
        switch self {
        case .critical: return "exclamationmark.triangle.fill"
        case .high: return "exclamationmark.circle.fill"
        case .medium: return "exclamationmark.circle"
        case .low: return "info.circle"
        }
    }
}

enum BlockerStatus: String, Codable {
    case active
    case resolved
    case snoozed
    case falsePositive = "false_positive"
}
```

**new viewmodel:** `BlockerDashboardViewModel.swift`
```swift
@MainActor
class BlockerDashboardViewModel: ObservableObject {
    @Published var activeBlockers: [Blocker] = []
    @Published var isLoading = false
    @Published var errorMessage: String?
    
    private let firestoreService = FirestoreService.shared
    private var listenerTasks: [Task<Void, Never>] = []
    
    func loadActiveBlockers(for userId: String) async {
        isLoading = true
        
        // get all conversations user is part of
        let conversations = try? await firestoreService.getUserConversations(userId: userId).first(where: { _ in true })
        
        guard let conversations = conversations else {
            isLoading = false
            return
        }
        
        // fetch active blockers from each conversation
        var allBlockers: [Blocker] = []
        
        for conversation in conversations {
            let blockersQuery = Firestore.firestore()
                .collection("conversations").document(conversation.id)
                .collection("blockers")
                .whereField("status", isEqualTo: "active")
            
            let snapshot = try? await blockersQuery.getDocuments()
            
            let blockers = snapshot?.documents.compactMap { doc -> Blocker? in
                try? doc.data(as: Blocker.self)
            } ?? []
            
            allBlockers.append(contentsOf: blockers)
        }
        
        // sort by severity (critical first) then by time (oldest first)
        self.activeBlockers = allBlockers.sorted { b1, b2 in
            if b1.severity != b2.severity {
                return severityRank(b1.severity) < severityRank(b2.severity)
            }
            return b1.detectedAt < b2.detectedAt
        }
        
        isLoading = false
    }
    
    private func severityRank(_ severity: BlockerSeverity) -> Int {
        switch severity {
        case .critical: return 0
        case .high: return 1
        case .medium: return 2
        case .low: return 3
        }
    }
    
    func markResolved(_ blocker: Blocker, notes: String?, currentUserId: String) async {
        let blockerRef = Firestore.firestore()
            .collection("conversations").document(blocker.conversationId)
            .collection("blockers").document(blocker.id)
        
        try? await blockerRef.updateData([
            "status": "resolved",
            "resolvedAt": Date(),
            "resolvedBy": currentUserId,
            "resolutionNotes": notes ?? ""
        ])
        
        // remove from active list
        activeBlockers.removeAll { $0.id == blocker.id }
    }
    
    func snooze(_ blocker: Blocker, duration: TimeInterval) async {
        let blockerRef = Firestore.firestore()
            .collection("conversations").document(blocker.conversationId)
            .collection("blockers").document(blocker.id)
        
        let snoozedUntil = Date().addingTimeInterval(duration)
        
        try? await blockerRef.updateData([
            "status": "snoozed",
            "snoozedUntil": snoozedUntil
        ])
        
        // remove from active list
        activeBlockers.removeAll { $0.id == blocker.id }
    }
    
    func markFalsePositive(_ blocker: Blocker) async {
        let blockerRef = Firestore.firestore()
            .collection("conversations").document(blocker.conversationId)
            .collection("blockers").document(blocker.id)
        
        try? await blockerRef.updateData([
            "status": "false_positive",
            "managerMarkedFalsePositive": true
        ])
        
        // remove from active list
        activeBlockers.removeAll { $0.id == blocker.id }
    }
}
```

**new view:** `BlockerDashboardView.swift`
```swift
struct BlockerDashboardView: View {
    @StateObject private var viewModel = BlockerDashboardViewModel()
    @EnvironmentObject var appState: AppStateService
    
    var body: some View {
        NavigationView {
            Group {
                if viewModel.isLoading {
                    ProgressView("loading blockers...")
                } else if viewModel.activeBlockers.isEmpty {
                    VStack(spacing: 16) {
                        Image(systemName: "checkmark.circle.fill")
                            .font(.system(size: 64))
                            .foregroundColor(.green)
                        Text("no active blockers üéâ")
                            .font(.title2)
                            .fontWeight(.bold)
                        Text("your team is flowing smoothly")
                            .font(.body)
                            .foregroundColor(.gray)
                    }
                    .padding()
                } else {
                    List {
                        ForEach(viewModel.activeBlockers) { blocker in
                            BlockerCard(
                                blocker: blocker,
                                onResolve: { notes in
                                    Task {
                                        await viewModel.markResolved(blocker, notes: notes, currentUserId: appState.currentUser?.id ?? "")
                                    }
                                },
                                onSnooze: { duration in
                                    Task {
                                        await viewModel.snooze(blocker, duration: duration)
                                    }
                                },
                                onMarkFalsePositive: {
                                    Task {
                                        await viewModel.markFalsePositive(blocker)
                                    }
                                }
                            )
                        }
                    }
                    .listStyle(.plain)
                }
            }
            .navigationTitle("team blockers")
            .navigationBarTitleDisplayMode(.large)
            .refreshable {
                if let userId = appState.currentUser?.id {
                    await viewModel.loadActiveBlockers(for: userId)
                }
            }
        }
        .task {
            if let userId = appState.currentUser?.id {
                await viewModel.loadActiveBlockers(for: userId)
            }
        }
    }
}

struct BlockerCard: View {
    let blocker: Blocker
    let onResolve: (String?) -> Void
    let onSnooze: (TimeInterval) -> Void
    let onMarkFalsePositive: () -> Void
    
    @State private var showingResolveSheet = false
    @State private var resolutionNotes = ""
    
    var timeElapsed: String {
        let interval = Date().timeIntervalSince(blocker.detectedAt)
        let hours = Int(interval) / 3600
        if hours < 1 {
            let minutes = Int(interval) / 60
            return "\(minutes) min ago"
        } else if hours < 24 {
            return "\(hours) hours ago"
        } else {
            let days = hours / 24
            return "\(days) days ago"
        }
    }
    
    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            // header: severity + time
            HStack {
                Image(systemName: blocker.severity.icon)
                    .foregroundColor(blocker.severity.color)
                Text(blocker.severity.rawValue.uppercased())
                    .font(.caption)
                    .fontWeight(.bold)
                    .foregroundColor(blocker.severity.color)
                Spacer()
                Text(timeElapsed)
                    .font(.caption)
                    .foregroundColor(.gray)
            }
            
            // blocked person
            HStack {
                Image(systemName: "person.circle.fill")
                    .foregroundColor(.blue)
                Text(blocker.blockedUserName)
                    .font(.headline)
            }
            
            // blocker description
            Text("blocked on: \(blocker.blockerDescription)")
                .font(.body)
                .foregroundColor(.primary)
            
            // type
            Text("type: \(blocker.blockerType.rawValue)")
                .font(.caption)
                .foregroundColor(.gray)
            
            // suggested actions
            if !blocker.suggestedActions.isEmpty {
                VStack(alignment: .leading, spacing: 4) {
                    Text("suggested actions:")
                        .font(.caption)
                        .fontWeight(.semibold)
                        .foregroundColor(.gray)
                    
                    ForEach(blocker.suggestedActions, id: \.self) { action in
                        HStack(alignment: .top, spacing: 4) {
                            Text("‚Ä¢")
                            Text(action)
                                .font(.caption)
                        }
                    }
                }
            }
            
            // actions
            HStack(spacing: 12) {
                Button(action: { showingResolveSheet = true }) {
                    Text("mark resolved")
                        .font(.caption)
                        .foregroundColor(.white)
                        .padding(.horizontal, 12)
                        .padding(.vertical, 6)
                        .background(Color.green)
                        .cornerRadius(8)
                }
                
                Menu {
                    Button("1 hour") { onSnooze(3600) }
                    Button("4 hours") { onSnooze(14400) }
                    Button("1 day") { onSnooze(86400) }
                } label: {
                    Text("snooze")
                        .font(.caption)
                        .foregroundColor(.white)
                        .padding(.horizontal, 12)
                        .padding(.vertical, 6)
                        .background(Color.orange)
                        .cornerRadius(8)
                }
                
                Button(action: onMarkFalsePositive) {
                    Text("false positive")
                        .font(.caption)
                        .foregroundColor(.white)
                        .padding(.horizontal, 12)
                        .padding(.vertical, 6)
                        .background(Color.gray)
                        .cornerRadius(8)
                }
            }
        }
        .padding()
        .background(Color(.systemGray6))
        .cornerRadius(12)
        .sheet(isPresented: $showingResolveSheet) {
            NavigationView {
                VStack {
                    Text("resolution notes (optional)")
                        .font(.headline)
                        .padding()
                    
                    TextEditor(text: $resolutionNotes)
                        .frame(height: 100)
                        .padding()
                        .background(Color(.systemGray6))
                        .cornerRadius(8)
                        .padding()
                    
                    Button("mark as resolved") {
                        onResolve(resolutionNotes.isEmpty ? nil : resolutionNotes)
                        showingResolveSheet = false
                        resolutionNotes = ""
                    }
                    .buttonStyle(.borderedProminent)
                    
                    Spacer()
                }
                .navigationTitle("resolve blocker")
                .navigationBarTitleDisplayMode(.inline)
                .toolbar {
                    ToolbarItem(placement: .cancellationAction) {
                        Button("cancel") {
                            showingResolveSheet = false
                        }
                    }
                }
            }
        }
    }
}
```

**performance targets:**
- detect blockers in real time as messages arrive
- blocker detection completes in < 2 seconds (background, non blocking)
- dashboard loads in < 1 second
- don't spam notifications (only critical/high severity)
- batch multiple blockers detected within 5 minutes into single notification

## Feature 3: Team Sentiment Analysis

### the value proposition

**spot morale issues 2 3 days earlier** than you would normally notice. when a team member's sentiment drops for 3 consecutive days, you know to check in before they burn out or quit.

**understand team health trends** over time. is the team generally positive and engaged? or is stress building? sentiment dashboard provides objective data to complement your intuition.

**prevent burnout** by identifying when specific team members are showing elevated stress levels. proactive check ins ("hey, noticed you seem stressed this week. what can i do to help?") make team members feel supported.

**improve team dynamics** by tracking overall team sentiment. if team sentiment drops after specific events (deployments, all hands, policy changes), you have data to inform decisions.

### sentiment detection approach

**what is sentiment?**
sentiment is the emotional tone and mood expressed in messages. it ranges from very positive (enthusiastic, happy, appreciative) to very negative (frustrated, stressed, angry, sad).

**sentiment scoring system:**
- **-1.0 to -0.5**: very negative (red) - frustrated, angry, stressed, burned out
- **-0.5 to -0.2**: negative (orange) - concerned, worried, mildly frustrated
- **-0.2 to +0.2**: neutral (gray) - factual, professional, no strong emotion
- **+0.2 to +0.5**: positive (light green) - satisfied, optimistic, collaborative
- **+0.5 to +1.0**: very positive (green) - enthusiastic, excited, appreciative

**positive sentiment indicators:**
- enthusiastic language: "great!", "awesome!", "excited about this!", "love it!", "fantastic work!"
- progress updates: "shipped the feature", "finished ahead of schedule", "nailed it"
- appreciation: "thanks for your help", "really appreciate this", "great work team"
- collaborative tone: "let's do this", "we got this", "team effort", "happy to help"
- success celebration: "just launched", "first customer signed", "hit our goal"
- emojis: üòä, üéâ, üëç, ‚ù§Ô∏è, üöÄ, ‚ú®, üî• (in positive context)

**negative sentiment indicators:**
- frustration: "this is so frustrating", "why isn't this working?", "this keeps failing", "nothing works"
- stress: "overwhelmed", "too much on my plate", "can't keep up", "so behind", "drowning in work"
- confusion: "i don't understand", "this doesn't make sense", "completely lost", "no idea how"
- burnout: "exhausted", "need a break", "can't do this anymore", "working too many hours"
- conflict: "i disagree", "that's not right", "this is a problem", "this doesn't work"
- technical problems (when repeated): "still broken", "another bug", "failed again"
- emojis: üòû, üò§, üòì, üò∞, üò¢, ü§Ø

**neutral sentiment indicators:**
- factual statements: "the meeting is at 3pm", "updated the document", "deployed to staging"
- questions without emotion: "what's the status?", "when is this due?", "who's working on this?"
- professional updates: "completed the task", "reviewing the pr", "attending the standup"
- acknowledgments: "ok", "sounds good", "got it", "will do"

**context matters (same words, different sentiment):**
- "working on this over the weekend" could be:
  - positive: if person sounds excited about project ("can't wait to finish this feature!")
  - negative: if person sounds resentful or exhausted ("have to work weekends again...")
  - ai must consider surrounding messages and tone
  
- "this is challenging" could be:
  - positive: if framed as exciting challenge ("this is challenging but i'm learning a lot!")
  - negative: if framed as overwhelming ("this is too challenging, i'm stuck")

**sarcasm detection:**
ai must distinguish sarcasm from genuine sentiment:
- "oh great, another meeting" - negative (sarcastic)
- "great work on the launch!" - positive (genuine)
- context and word choice help determine this

### aggregation levels

**1. individual message sentiment:**
- each text message gets scored: -1.0 to +1.0
- stored with message for historical analysis
- contributes to higher level aggregates

**2. conversation sentiment:**
- average of last 15 20 messages in conversation
- weighted toward recent messages (last 5 messages have 2x weight)
- shows whether current conversation tone is positive, neutral, or negative
- helpful for identifying toxic or dysfunctional conversations

**3. individual team member sentiment (daily):**
- average of all messages sent by person across all conversations in past 24 hours
- minimum 3 messages required for valid score
- shows person's overall mood that day
- updated hourly

**4. individual team member sentiment (7 day):**
- average of daily sentiments over past 7 days
- shows person's overall state this week
- identifies trends: improving, stable, or declining

**5. overall team sentiment (daily):**
- average of all team members' daily sentiments
- gives holistic view of team morale today
- updated hourly

**6. overall team sentiment (7 day trend):**
- daily team sentiment values over past 7 days
- shown as line graph
- helps identify if team is trending up or down

### user experience flow

**step 1: continuous background analysis (invisible)**
- every new text message gets sentiment analyzed
- ai analyzes message in context of recent conversation
- sentiment score saved to message document
- hourly job calculates aggregate scores

**step 2: manager opens sentiment dashboard**
- navigates to sentiment dashboard from conversation or main menu
- dashboard loads showing:
  - overall team sentiment score (0 100 scale, where 50 is neutral)
  - sentiment category: very positive, positive, neutral, negative, very negative
  - 7 day trend graph showing team sentiment over time
  - individual team member cards sorted by concern (negative sentiment first)

**step 3: manager reviews team overview**
- team sentiment card shows:
  - large circular indicator colored by sentiment (green to red)
  - sentiment score: 65/100 (positive)
  - change from last week: "‚Üë 8 points this week" (improving)
  - line graph showing past 7 days trend
  - quick stats: "3 members positive, 1 neutral, 1 showing stress"

**step 4: manager reviews individual team members**
- list of team member cards showing:
  - member name and avatar
  - sentiment score and colored indicator
  - trend arrow (‚Üë improving, ‚Üí stable, ‚Üì declining)
  - top emotions detected: stressed, frustrated, excited, etc
  - last analyzed: "2 hours ago"
- sorted by concerning sentiment first (negative to positive)

**step 5: manager investigates concerning sentiment**
- taps on sarah's card (showing negative sentiment for 3 days)
- opens individual sentiment detail view showing:
  - sarah's sentiment history graph (past 30 days)
  - recent messages contributing to negative sentiment (with context)
  - emotions detected over time: frustrated (40%), stressed (30%), confused (20%)
  - suggested actions:
    - "schedule a 1 on 1 check in"
    - "ask if she needs support or resources"
    - "acknowledge her concerns"
  - privacy note: "this data is for team support, not performance evaluation"

**step 6: manager takes proactive action**
- messages sarah: "hey, noticed you've seemed a bit stressed this week. everything ok? anything i can help with?"
- or schedules 1 on 1 meeting to check in
- marks sarah's sentiment alert as "addressed"

**step 7: alert for significant drop**
- notification: "team sentiment dropped 15 points this week"
- manager opens dashboard to investigate
- sees 3 team members showing elevated stress after recent deployment
- addresses root cause: deployment process is too stressful
- implements improvements

### sentiment dashboard design

**team overview card:**
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Team Sentiment                              ‚îÇ
‚îÇ                                              ‚îÇ
‚îÇ      ‚óè                     Positive          ‚îÇ
‚îÇ     68                                       ‚îÇ
‚îÇ    /100                                      ‚îÇ
‚îÇ                                              ‚îÇ
‚îÇ  ‚Üë 12 points this week                      ‚îÇ
‚îÇ                                              ‚îÇ
‚îÇ  [Line graph showing 7 day trend]           ‚îÇ
‚îÇ                                              ‚îÇ
‚îÇ  3 positive  |  1 neutral  |  1 stressed    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**individual member card:**
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  üë§ Sarah Chen                          ‚Üì    ‚îÇ
‚îÇ                                              ‚îÇ
‚îÇ  ‚óè 32/100  Negative                         ‚îÇ
‚îÇ                                              ‚îÇ
‚îÇ  Emotions: Frustrated (40%), Stressed (30%) ‚îÇ
‚îÇ  Last 3 days: negative                      ‚îÇ
‚îÇ                                              ‚îÇ
‚îÇ  [Tap to view details]                      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**individual detail view:**
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Sarah Chen - Sentiment History              ‚îÇ
‚îÇ                                              ‚îÇ
‚îÇ  [30 day line graph showing sentiment]      ‚îÇ
‚îÇ                                              ‚îÇ
‚îÇ  Recent Messages (negative sentiment):       ‚îÇ
‚îÇ                                              ‚îÇ
‚îÇ  üòì "this is so frustrating, nothing is     ‚îÇ
‚îÇ  working right" - 2 days ago                 ‚îÇ
‚îÇ                                              ‚îÇ
‚îÇ  üò§ "i'm completely stuck on this, been     ‚îÇ
‚îÇ  trying for hours" - 1 day ago               ‚îÇ
‚îÇ                                              ‚îÇ
‚îÇ  Suggested Actions:                          ‚îÇ
‚îÇ  ‚Ä¢ Schedule 1-on-1 check-in                 ‚îÇ
‚îÇ  ‚Ä¢ Ask if she needs support                  ‚îÇ
‚îÇ  ‚Ä¢ Acknowledge her concerns                  ‚îÇ
‚îÇ                                              ‚îÇ
‚îÇ  [Check In] [View Conversation]             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### technical implementation

**extend message schema:**
```
/conversations/{conversationId}/messages/{messageId}
  [existing fields...]
  
  // new sentiment fields
  sentimentScore: number (-1.0 to 1.0) | null
  sentimentAnalysis: {
    score: number
    emotions: string[] (frustrated, excited, stressed, etc)
    confidence: number (0.0 to 1.0)
    analyzedAt: timestamp
    reasoning: string (brief explanation)
  } | null
```

**new collections for aggregates:**
```
/sentimentTracking/userDaily/{date_userId}
  userId: string
  date: string (yyyy-mm-dd)
  averageSentiment: number (-1.0 to 1.0)
  messageCount: number
  emotionsDetected: { emotion: count }
  trend: 'improving'|'stable'|'declining'

/sentimentTracking/userWeekly/{userId}
  userId: string
  weekStartDate: string (yyyy-mm-dd)
  dailyScores: { date: score }
  averageSentiment: number
  trend: 'improving'|'stable'|'declining'

/sentimentTracking/teamDaily/{date_conversationId}
  conversationId: string
  date: string
  averageSentiment: number
  memberSentiments: { userId: score }
  trend: 'improving'|'stable'|'declining'

/sentimentTracking/teamWeekly/{conversationId}
  conversationId: string
  weekStartDate: string
  dailyScores: { date: score }
  averageSentiment: number
  trend: 'improving'|'stable'|'declining'
```

**new cloud function: analyzeSentiment**

**location:** `functions/src/ai/sentiment.ts`

**configuration:**
- timeout: 10 seconds
- memory: 512mb
- triggers: firestore onCreate trigger

**firestore trigger:**
```typescript
export const onMessageCreatedAnalyzeSentiment = functions.firestore
  .document('conversations/{conversationId}/messages/{messageId}')
  .onCreate(async (snap, context) => {
    const message = snap.data();
    
    // only analyze text messages
    if (message.type !== 'text') {
      console.log(`‚è≠Ô∏è message is not text, skipping sentiment analysis`);
      return;
    }
    
    // call sentiment analysis
    try {
      await analyzeSentiment({
        conversationId: context.params.conversationId,
        messageId: context.params.messageId
      });
    } catch (error) {
      console.error(`‚ùå sentiment analysis failed:`, error);
      // don't throw - analysis failure shouldn't break message delivery
    }
  });
```

**main analyzeSentiment function:**
```typescript
export const analyzeSentiment = functions
  .runWith({ timeoutSeconds: 10, memory: '512MB' })
  .https.onCall(async (data, context) => {
    const { conversationId, messageId } = data;
    
    console.log(`üòä analyzing sentiment for message ${messageId}...`);
    
    // fetch message
    const messageDoc = await admin.firestore()
      .collection('conversations').doc(conversationId)
      .collection('messages').doc(messageId)
      .get();
    
    if (!messageDoc.exists) {
      throw new functions.https.HttpsError('not-found', 'message not found');
    }
    
    const message = messageDoc.data();
    
    // fetch recent messages for context (last 10)
    const contextMessages = await admin.firestore()
      .collection('conversations').doc(conversationId)
      .collection('messages')
      .orderBy('createdAt', 'desc')
      .limit(10)
      .get();
    
    const transcript = contextMessages.docs
      .reverse()
      .map(doc => {
        const msg = doc.data();
        return `${msg.senderName}: ${msg.text}`;
      })
      .join('\n');
    
    // call openai
    const apiKey = functions.config().openai?.key;
    if (!apiKey) {
      throw new functions.https.HttpsError('failed-precondition', 'openai api key not configured');
    }
    
    const openai = new OpenAI({ apiKey });
    
    const prompt = `analyze the sentiment and emotional tone of this message.

conversation context (recent messages for tone):
${transcript}

message to analyze:
"${message.text}" - sent by ${message.senderName}

analyze:
1. sentiment score: -1.0 (very negative) to +1.0 (very positive), 0 is neutral
2. specific emotions present: frustrated, excited, stressed, confused, happy, worried, angry, enthusiastic, etc
3. confidence in this analysis: 0.0 to 1.0
4. brief reasoning: one sentence explaining the score

context is important:
- "working on this over the weekend" could be positive (excited) or negative (overwhelmed)
- consider surrounding messages to understand true sentiment
- distinguish sarcasm ("oh great, another meeting" is negative)
- professional neutral statements should score near 0

return json (no markdown, no code fences):
{
  "score": -0.4,
  "emotions": ["frustrated", "stressed"],
  "confidence": 0.85,
  "reasoning": "expresses frustration with work problems and mentions feeling overwhelmed"
}`;

    console.log(`ü§ñ calling gpt-4o for sentiment analysis...`);
    
    const response = await openai.chat.completions.create({
      model: 'gpt-4o',
      temperature: 0.2,
      max_tokens: 300,
      messages: [
        {
          role: 'system',
          content: 'you are an expert at analyzing emotional tone and sentiment in workplace messages. be accurate and context aware. return only valid json.'
        },
        {
          role: 'user',
          content: prompt
        }
      ]
    });
    
    const responseText = response.choices[0]?.message?.content || '{}';
    console.log(`üìä ai response: ${responseText}`);
    
    // parse response
    let result;
    try {
      let jsonText = responseText.trim();
      if (jsonText.startsWith('```')) {
        jsonText = jsonText.replace(/```json?\n?/g, '').replace(/```\n?/g, '');
      }
      result = JSON.parse(jsonText);
    } catch (error) {
      console.error(`‚ùå failed to parse ai response:`, error);
      return { success: false, error: 'invalid ai response' };
    }
    
    // validate score range
    if (result.score < -1.0 || result.score > 1.0) {
      console.error(`‚ùå invalid sentiment score: ${result.score}`);
      result.score = Math.max(-1.0, Math.min(1.0, result.score));
    }
    
    // only save if confidence is reasonable
    if (result.confidence < 0.5) {
      console.log(`‚ö†Ô∏è confidence too low (${result.confidence}), not saving sentiment`);
      return { success: true, sentiment: null, reason: 'low confidence' };
    }
    
    // save sentiment to message
    console.log(`üíæ saving sentiment (score: ${result.score}, confidence: ${result.confidence})...`);
    
    const sentimentAnalysis = {
      score: result.score,
      emotions: result.emotions || [],
      confidence: result.confidence,
      analyzedAt: admin.firestore.FieldValue.serverTimestamp(),
      reasoning: result.reasoning || ''
    };
    
    await messageDoc.ref.update({
      sentimentScore: result.score,
      sentimentAnalysis: sentimentAnalysis
    });
    
    console.log(`‚úÖ sentiment saved to message`);
    
    return { 
      success: true, 
      sentiment: {
        score: result.score,
        ...sentimentAnalysis
      }
    };
  });
```

**scheduled function for aggregates:**
```typescript
export const calculateSentimentAggregates = functions.pubsub
  .schedule('every 1 hours')
  .timeZone('America/Los_Angeles')
  .onRun(async (context) => {
    console.log(`üîÑ calculating sentiment aggregates...`);
    
    const now = new Date();
    const todayStr = now.toISOString().split('T')[0]; // yyyy-mm-dd
    
    // get all users
    const usersSnapshot = await admin.firestore().collection('users').get();
    
    for (const userDoc of usersSnapshot.docs) {
      const userId = userDoc.id;
      
      // get all messages by this user today with sentiment
      const messagesSnapshot = await admin.firestore()
        .collectionGroup('messages')
        .where('senderId', '==', userId)
        .where('sentimentScore', '!=', null)
        .where('createdAt', '>', new Date(Date.now() - 24 * 60 * 60 * 1000))
        .get();
      
      if (messagesSnapshot.empty) {
        console.log(`‚è≠Ô∏è no messages with sentiment for user ${userId} today`);
        continue;
      }
      
      // calculate average sentiment
      let totalSentiment = 0;
      const emotionCounts: { [emotion: string]: number } = {};
      
      for (const msgDoc of messagesSnapshot.docs) {
        const msg = msgDoc.data();
        totalSentiment += msg.sentimentScore;
        
        if (msg.sentimentAnalysis?.emotions) {
          for (const emotion of msg.sentimentAnalysis.emotions) {
            emotionCounts[emotion] = (emotionCounts[emotion] || 0) + 1;
          }
        }
      }
      
      const averageSentiment = totalSentiment / messagesSnapshot.size;
      
      // get yesterday's sentiment to determine trend
      const yesterdayStr = new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString().split('T')[0];
      const yesterdayDoc = await admin.firestore()
        .collection('sentimentTracking')
        .doc('userDaily')
        .collection('aggregates')
        .doc(`${yesterdayStr}_${userId}`)
        .get();
      
      let trend: 'improving' | 'stable' | 'declining' = 'stable';
      if (yesterdayDoc.exists) {
        const yesterdaySentiment = yesterdayDoc.data()?.averageSentiment || 0;
        const change = averageSentiment - yesterdaySentiment;
        if (change > 0.2) trend = 'improving';
        else if (change < -0.2) trend = 'declining';
      }
      
      // save daily aggregate
      await admin.firestore()
        .collection('sentimentTracking')
        .doc('userDaily')
        .collection('aggregates')
        .doc(`${todayStr}_${userId}`)
        .set({
          userId: userId,
          date: todayStr,
          averageSentiment: averageSentiment,
          messageCount: messagesSnapshot.size,
          emotionsDetected: emotionCounts,
          trend: trend,
          calculatedAt: admin.firestore.FieldValue.serverTimestamp()
        });
      
      console.log(`‚úÖ saved daily sentiment for user ${userId}: ${averageSentiment.toFixed(2)}`);
    }
    
    // calculate team aggregates (for group conversations)
    const conversationsSnapshot = await admin.firestore()
      .collection('conversations')
      .where('type', '==', 'group')
      .get();
    
    for (const convoDoc of conversationsSnapshot.docs) {
      const conversationId = convoDoc.id;
      const conversation = convoDoc.data();
      const participantIds = conversation.participantIds || [];
      
      // get today's sentiment for each team member
      const memberSentiments: { [userId: string]: number } = {};
      let totalSentiment = 0;
      let memberCount = 0;
      
      for (const userId of participantIds) {
        const userDailyDoc = await admin.firestore()
          .collection('sentimentTracking')
          .doc('userDaily')
          .collection('aggregates')
          .doc(`${todayStr}_${userId}`)
          .get();
        
        if (userDailyDoc.exists) {
          const sentiment = userDailyDoc.data()?.averageSentiment || 0;
          memberSentiments[userId] = sentiment;
          totalSentiment += sentiment;
          memberCount++;
        }
      }
      
      if (memberCount === 0) continue;
      
      const teamAverageSentiment = totalSentiment / memberCount;
      
      // determine trend
      const yesterdayTeamDoc = await admin.firestore()
        .collection('sentimentTracking')
        .doc('teamDaily')
        .collection('aggregates')
        .doc(`${yesterdayStr}_${conversationId}`)
        .get();
      
      let trend: 'improving' | 'stable' | 'declining' = 'stable';
      if (yesterdayTeamDoc.exists) {
        const yesterdayTeamSentiment = yesterdayTeamDoc.data()?.averageSentiment || 0;
        const change = teamAverageSentiment - yesterdayTeamSentiment;
        if (change > 0.15) trend = 'improving';
        else if (change < -0.15) trend = 'declining';
      }
      
      // save team aggregate
      await admin.firestore()
        .collection('sentimentTracking')
        .doc('teamDaily')
        .collection('aggregates')
        .doc(`${todayStr}_${conversationId}`)
        .set({
          conversationId: conversationId,
          date: todayStr,
          averageSentiment: teamAverageSentiment,
          memberSentiments: memberSentiments,
          trend: trend,
          calculatedAt: admin.firestore.FieldValue.serverTimestamp()
        });
      
      console.log(`‚úÖ saved team sentiment for conversation ${conversationId}: ${teamAverageSentiment.toFixed(2)}`);
      
      // check for alerts (significant drop)
      if (yesterdayTeamDoc.exists) {
        const yesterdayTeamSentiment = yesterdayTeamDoc.data()?.averageSentiment || 0;
        const drop = yesterdayTeamSentiment - teamAverageSentiment;
        
        if (drop > 0.3) {
          console.log(`üö® significant sentiment drop detected: ${drop.toFixed(2)}`);
          // send alert to managers (participants in conversation)
          // implementation would create alert documents and send notifications
        }
      }
    }
    
    console.log(`‚úÖ sentiment aggregates calculation complete`);
  });
```

**swift integration:**

**models:** already defined in previous section

**viewmodel:** `SentimentDashboardViewModel.swift`
```swift
@MainActor
class SentimentDashboardViewModel: ObservableObject {
    @Published var teamSentiment: Double = 0.0 // -1.0 to 1.0
    @Published var sentimentTrend: [Date: Double] = [:]
    @Published var memberSentiments: [SentimentData] = []
    @Published var isLoading = false
    @Published var errorMessage: String?
    
    private let db = Firestore.firestore()
    
    func loadTeamSentiment(for conversationId: String) async {
        isLoading = true
        
        // get today's date string
        let dateFormatter = DateFormatter()
        dateFormatter.dateFormat = "yyyy-MM-dd"
        let todayStr = dateFormatter.string(from: Date())
        
        // fetch team aggregate for today
        let teamAggregateRef = db
            .collection("sentimentTracking")
            .document("teamDaily")
            .collection("aggregates")
            .document("\(todayStr)_\(conversationId)")
        
        do {
            let teamDoc = try await teamAggregateRef.getDocument()
            
            if let teamData = teamDoc.data() {
                self.teamSentiment = teamData["averageSentiment"] as? Double ?? 0.0
                
                // fetch trend data (past 7 days)
                await loadSentimentTrend(for: conversationId)
                
                // fetch individual member sentiments
                if let memberSentiments = teamData["memberSentiments"] as? [String: Double] {
                    await loadMemberDetails(memberSentiments: memberSentiments)
                }
            }
            
            isLoading = false
        } catch {
            print("‚ùå failed to load team sentiment: \(error)")
            self.errorMessage = "couldn't load sentiment data"
            isLoading = false
        }
    }
    
    private func loadSentimentTrend(for conversationId: String) async {
        let dateFormatter = DateFormatter()
        dateFormatter.dateFormat = "yyyy-MM-dd"
        
        var trendData: [Date: Double] = [:]
        
        // fetch past 7 days
        for daysAgo in 0..<7 {
            let date = Calendar.current.date(byAdding: .day, value: -daysAgo, to: Date())!
            let dateStr = dateFormatter.string(from: date)
            
            let docRef = db
                .collection("sentimentTracking")
                .document("teamDaily")
                .collection("aggregates")
                .document("\(dateStr)_\(conversationId)")
            
            if let doc = try? await docRef.getDocument(),
               let sentiment = doc.data()?["averageSentiment"] as? Double {
                trendData[date] = sentiment
            }
        }
        
        self.sentimentTrend = trendData
    }
    
    private func loadMemberDetails(memberSentiments: [String: Double]) async {
        var sentimentDataArray: [SentimentData] = []
        
        let dateFormatter = DateFormatter()
        dateFormatter.dateFormat = "yyyy-MM-dd"
        let todayStr = dateFormatter.string(from: Date())
        
        for (userId, sentiment) in memberSentiments {
            // fetch user info
            let userDoc = try? await db.collection("users").document(userId).getDocument()
            let userName = userDoc?.data()?["displayName"] as? String ?? "unknown"
            
            // fetch detailed aggregate
            let aggregateDoc = try? await db
                .collection("sentimentTracking")
                .document("userDaily")
                .collection("aggregates")
                .document("\(todayStr)_\(userId)")
                .getDocument()
            
            let messageCount = aggregateDoc?.data()?["messageCount"] as? Int ?? 0
            let emotionsDetected = aggregateDoc?.data()?["emotionsDetected"] as? [String: Int] ?? [:]
            let trend = SentimentTrend(rawValue: aggregateDoc?.data()?["trend"] as? String ?? "stable") ?? .stable
            
            let sentimentData = SentimentData(
                id: userId,
                userId: userId,
                userName: userName,
                averageSentiment: sentiment,
                trend: trend,
                messageCount: messageCount,
                emotionsDetected: emotionsDetected,
                lastAnalyzed: Date()
            )
            
            sentimentDataArray.append(sentimentData)
        }
        
        // sort by concerning sentiment first (negative to positive)
        self.memberSentiments = sentimentDataArray.sorted { $0.averageSentiment < $1.averageSentiment }
    }
}
```

**views:** `SentimentDashboardView.swift`, `TeamSentimentCard.swift`, `MemberSentimentCard.swift`
(implementations provided in task breakdown - too long to repeat here)

**performance targets:**
- analyze sentiment in background without blocking ui
- sentiment analysis completes in < 2 seconds per message
- dashboard loads in < 1 second
- aggregate calculations run hourly (don't impact app performance)
- alerts triggered within 1 hour of significant drop

## Cross Feature Integration

### unified ai dashboard

create single dashboard showing insights from all ai features (existing + new):

**sections:**
1. response suggestions available (count of messages with pending suggestions)
2. active blockers (count, show top 2 critical/high blockers)
3. team sentiment (score, trend indicator)
4. priority messages (existing feature - count)
5. action items (existing feature - count pending)
6. recent ai insights (summaries, decisions)

**benefits:**
- single place to see everything ai detected
- quick overview of team status
- links to detailed views for each feature
- accessible from main navigation

### shared infrastructure

**reusable context gathering:**
create utility function used by all features:
```typescript
async function getConversationContext(
  conversationId: string, 
  limit: number = 20
): Promise<string> {
  // check cache first (5 min ttl)
  // if not cached, fetch and format messages
  // cache result
  // return formatted transcript
}
```

**benefits:**
- dry (don't repeat yourself)
- consistent formatting
- centralized caching
- reduces firestore reads

**batch ai calls where possible:**
when analyzing a message, consider running multiple analyses in parallel:
- blocker detection + sentiment analysis in single ai call
- reduces total ai api cost
- faster overall processing

### settings and privacy

**unified ai features settings panel:**

sections:
1. **smart response suggestions**
   - toggle: enable/disable
   - description: "ai powered response options save time"
   
2. **blocker detection**
   - toggle: enable/disable
   - toggle: blocker notifications (sub option)
   - description: "automatically identify when team members are stuck"
   
3. **sentiment analysis**
   - toggle: enable/disable
   - toggle: sentiment alerts (sub option)
   - description: "track team mood and morale over time"
   - privacy note: "sentiment analysis is for team support only, never for performance reviews or punitive purposes"

4. **existing ai features** (for reference)
   - thread summarization: always on
   - action items: always on
   - smart search: always on
   - priority detection: always on
   - decision tracking: always on

**opt out mechanisms:**
- respect toggles in all features
- if disabled, don't show ui components
- if disabled, don't run background processing
- if disabled, don't make ai api calls
- save preferences to firestore user.preferences
- sync across devices

**privacy transparency:**
- clear explanation of what data each feature analyzes
- emphasize supportive purpose (help managers support teams)
- never for surveillance or punishment
- data used to improve team health and productivity
- users can opt out anytime
- "learn more" links to detailed privacy documentation

## Implementation Strategy

### recommended implementation order

**phase 1: foundation (4 5 days)**
- create all database schemas
- create all swift models
- create cloud function scaffolds (empty functions that just auth and return stubs)
- verify scaffolds deploy successfully

**phase 2: core ai services (7 8 days)**
- build ai prompts for all three features
- implement openai api integration
- test prompt quality with real conversations
- deploy working cloud functions

**phase 3: background processing (2 3 days)**
- implement firestore triggers for auto detection
- implement scheduled aggregation function
- test background processing doesn't slow app

**phase 4: swift ui implementation (4 5 days)**
- build all viewmodels
- build all view components
- integrate into main app navigation
- polish ui/ux

**phase 5: integration and polish (3 4 days)**
- create unified ai dashboard
- implement settings panel
- optimize ai api usage (caching, batching)
- add privacy explanations
- comprehensive testing

**total estimated time: 20 25 days (1 developer)**

### dependencies

**no hard blockers:**
- all three features can be developed in parallel
- they use same infrastructure patterns
- can test each feature independently

**soft dependencies:**
- unified dashboard requires at least 2 features complete
- settings panel easier after all features defined
- optimization happens after baseline implementation

### testing strategy

**unit testing:**
- test ai prompt quality with 20+ sample conversations
- measure sentiment accuracy (80%+ target)
- measure blocker detection accuracy (85%+ target, < 10% false positives)
- measure suggestion relevance (70%+ usage rate target)

**integration testing:**
- test full flow: message ‚Üí ai analysis ‚Üí ui display ‚Üí user action
- test background processing performance
- test caching reduces redundant calls
- test error handling (ai failures, timeouts)

**user testing with ios simulator:**
- simulate realistic team conversations
- verify all features work end to end
- gather feedback on ai quality
- measure actual time saved and value provided

## Success Metrics

### feature 1: smart response suggestions
- **adoption rate**: 40%+ of suggestions used or edited before sending
- **time saved**: average response time reduced by 30%
- **satisfaction**: 80%+ rate suggestions as helpful
- **false triggers**: < 15% of suggestion displays are for messages not needing response

### feature 2: proactive blocker detection
- **detection accuracy**: 85%+ of real blockers detected
- **false positive rate**: < 10% of detected blockers are not real blockers
- **response time**: managers act on 70%+ of critical/high blockers within 2 hours
- **blocker resolution time**: average time to resolve blockers reduced by 40%

### feature 3: team sentiment analysis
- **accuracy**: 80%+ correlation between ai sentiment and manager's human assessment
- **early warning**: detect sentiment drops 2 3 days before manager would normally notice
- **actionability**: managers take supportive action on 50%+ of sentiment alerts
- **value**: 70%+ of managers find sentiment dashboard helpful for team management

### overall ai features (including existing + new)
- **daily usage**: 90%+ of managers use at least one ai feature daily
- **satisfaction**: 4.5+ out of 5 stars overall ai features rating
- **retention**: < 5% disable ai features after trying them
- **performance**: all features complete in < 3 seconds, app remains responsive

## Risk Mitigation

### risk: ai responses low quality or irrelevant

**mitigation:**
- extensive prompt engineering with real conversation testing
- provide rich context (conversation history, user style)
- confidence thresholds (only show high confidence results)
- user feedback improves future results
- graceful degradation (don't show bad suggestions)

### risk: blocker detection too many false positives

**mitigation:**
- tune confidence threshold based on real usage
- allow managers to mark false positives (improves ai)
- only notify for critical/high severity
- provide full context so managers can quickly assess

### risk: sentiment analysis privacy concerns

**mitigation:**
- crystal clear privacy explanations
- emphasize supportive purpose only
- easy opt out for individuals or teams
- only analyze conversations manager is in
- transparent about data usage
- never punitive, only supportive

### risk: features too expensive (ai api costs)

**mitigation:**
- aggressive caching (5 min for suggestions, permanent for sentiment)
- batch processing where possible
- use gpt 4o mini for simpler tasks if needed
- monitor costs closely
- allow feature disabling to control costs

### risk: performance impact (slow app)

**mitigation:**
- all ai processing in cloud functions (not on device)
- background processing doesn't block ui
- show loading states for user initiated actions
- timeout after reasonable period
- monitor performance metrics

## acceptance criteria

### smart response suggestions
‚úÖ suggestions appear for messages requiring manager response
‚úÖ 3 4 contextually relevant suggestions generated
‚úÖ suggestions match different types (approve, decline, conditional, delegate)
‚úÖ tapping suggestion inserts into message input
‚úÖ can edit suggestion before sending
‚úÖ can dismiss if not helpful
‚úÖ suggestions improve based on usage patterns
‚úÖ no suggestions for casual/fyi messages
‚úÖ works within 3 seconds
‚úÖ clear that suggestions are ai generated

### proactive blocker detection
‚úÖ detects explicit blocker statements accurately
‚úÖ detects approval, resource, technical, people blockers
‚úÖ classifies severity correctly
‚úÖ manager receives notifications for critical/high only
‚úÖ blocker dashboard shows all active blockers
‚úÖ can view conversation context
‚úÖ can mark resolved, snoozed, false positive
‚úÖ background scanning doesn't slow app
‚úÖ works across all manager's conversations

### team sentiment analysis
‚úÖ accurately analyzes message sentiment
‚úÖ calculates individual and team sentiment scores
‚úÖ shows sentiment trends over time
‚úÖ identifies specific emotions
‚úÖ alerts on significant drops
‚úÖ individual detail view shows history
‚úÖ dashboard clear and actionable
‚úÖ background processing doesn't slow app
‚úÖ privacy controls clear

### integration
‚úÖ all features work together seamlessly
‚úÖ unified dashboard shows all insights
‚úÖ shared context gathering (efficient)
‚úÖ settings panel controls all features
‚úÖ integrates with existing ai features
‚úÖ consistent ui/ux

### performance
‚úÖ background processing doesn't block ui
‚úÖ < 3 seconds for most operations
‚úÖ efficient ai api usage
‚úÖ app responsive under load
‚úÖ reasonable battery and data usage

### privacy and code quality
‚úÖ clear privacy explanations
‚úÖ easy opt out
‚úÖ only analyzes manager's conversations
‚úÖ clean, maintainable code
‚úÖ no build errors or warnings
‚úÖ follows existing patterns
‚úÖ comprehensive error handling

## conclusion

these three advanced ai features transform messageai from an excellent messaging app into an **indispensable ai powered management assistant**. they provide tangible, measurable value:

**time saved:** 30 45 minutes per day from smart response suggestions
**problems prevented:** blockers caught early, morale issues spotted before they escalate
**team supported:** managers can proactively help their teams feel valued and supported

implementation is straightforward, building on proven patterns from existing ai features. the 20 25 day timeline is realistic for a single developer.

**beyond the rubric:** these features clearly differentiate messageai from competitors and create real competitive advantage. this is what gets managers to pay for premium features or recommend the app to their teams.
